"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _0x_js_1 = require("0x.js");
const connect_1 = require("@0xproject/connect");
const etherUtil = require("ethereumjs-util");
const AddressService_1 = require("./AddressService");
const TimeService_1 = require("./TimeService");
class ConnectService {
    constructor(relayerUrl, network) {
        this.httpClient = new connect_1.HttpClient(relayerUrl);
        this.exchangeContractAddress = AddressService_1.AddressService.getExchangekAddress(network);
    }
    getTokenPairs(makerTokenAddress, takerTokenAddress) {
        return this.httpClient.getTokenPairsAsync({
            tokenA: makerTokenAddress,
            tokenB: takerTokenAddress,
        }).then((tokenPairs) => {
            const filteredPairs = this.filterBothPairs(tokenPairs, makerTokenAddress, takerTokenAddress);
            return this.organizePairs(filteredPairs, makerTokenAddress);
        });
    }
    getOrderWithFee(maker, makerTokenAddress, takerTokenAddress, makerTokenAmount, takerTokenAmount, milisecondsToExpire) {
        const getFeeRequest = {
            exchangeContractAddress: this.exchangeContractAddress,
            expirationUnixTimestampSec: TimeService_1.TimeService.getTimeFromNow(milisecondsToExpire),
            maker: maker,
            makerTokenAddress: makerTokenAddress,
            makerTokenAmount: makerTokenAmount,
            salt: _0x_js_1.ZeroEx.generatePseudoRandomSalt(),
            taker: etherUtil.zeroAddress(),
            takerTokenAddress: takerTokenAddress,
            takerTokenAmount: takerTokenAmount,
        };
        return this.httpClient.getFeesAsync(getFeeRequest).then((fee) => {
            return {
                exchangeContractAddress: getFeeRequest.exchangeContractAddress,
                expirationUnixTimestampSec: getFeeRequest.expirationUnixTimestampSec,
                feeRecipient: fee.feeRecipient,
                maker: getFeeRequest.maker,
                makerFee: fee.makerFee,
                makerTokenAddress: getFeeRequest.makerTokenAddress,
                makerTokenAmount: getFeeRequest.makerTokenAmount,
                salt: getFeeRequest.salt,
                taker: getFeeRequest.taker,
                takerFee: fee.takerFee,
                takerTokenAddress: getFeeRequest.takerTokenAddress,
                takerTokenAmount: getFeeRequest.takerTokenAmount,
            };
        });
    }
    filterBothPairs(tokenPairs, makerTokenAddress, takerTokenAddress) {
        return tokenPairs.filter((pair) => {
            if (pair.tokenA.address === makerTokenAddress && pair.tokenB.address === takerTokenAddress) {
                return true;
            }
            if (pair.tokenB.address === makerTokenAddress && pair.tokenA.address === takerTokenAddress) {
                return true;
            }
            return false;
        });
    }
    organizePairs(tokenPairs, makerTokenAddress) {
        return tokenPairs.map((pair) => {
            if (pair.tokenA.address === makerTokenAddress) {
                return pair;
            }
            return {
                tokenA: pair.tokenB,
                tokenB: pair.tokenA,
            };
        });
    }
}
exports.ConnectService = ConnectService;
